@page "/cmd"
@inject IJSRuntime JSRuntime
@inject NavigationManager NavigationManager


<PageTitle>Youweb</PageTitle>

<div id="command_box" class="runCommand_command_box">
    @for(var item = 0; item < Returns.Count; item++)
    {
        var local = item;

        <p class="command">@Returns[local]</p>
    }
</div>
<br />
<input class="form-control" type="text" placeholder=">" @onkeydown="Enter" @bind="Cmd" />
<br />


<!--input class="form-control" type="text" placeholder="type your arguments" @bind="Arguments" />
<br /-->
<p>Session id: @SessionId</p>
<div class="btn btn-primary" @onclick="RunCmd">
    @RunBtnText
</div>
@code {
    string RunBtnText { get; set; } = "run";
    string Program {get;set;}
    string ReturnCommand { get; set; } = null;
    string Cmd { get; set; } = null;
    string swap_value { get; set; } = "";
    string SessionId{get;set;} = IRandom.RandomText(8);
    List<string> Returns = new List<string>();
    Task Command;
    Task PlayAnimation;
    Process CommandProcess;

    string GetArgsText()
    {
        return null;//this.Cmd.SubString(this.Cmd.IndexOf(' '));
    }
    string[] GetArgsArray()
    {
        string[] words = this.Cmd.Split(' ');
        this.Program = words[0];
        List<string> args = new List<string>();
        for(int arg = 1; arg < words.Length; arg++)
        {
            args.Add(words[arg]);
        }
        return args.ToArray();
    }
    async Task Enter(KeyboardEventArgs e)
    {
        //@onkeydown="@Enter"
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            this.RunCmd();
        }
    }
    string ParseCommands(string command)
    {
        string parsed = command;
        parsed = parsed.Replace("$(pwd)", YouwebStatic.GetRoot());
        return parsed;
    }

    string Swap()
    {
        switch (this.swap_value)
        {
            case "running...":
                this.swap_value = "running..";
                break;
            case "running..":
                this.swap_value = "running.";
                break;
            case "running.":
                this.swap_value = "running...";
                break;
        }
        return this.swap_value;
    }
    private async Task DownloadFile(string fileName)
    {
        string uri = new Uri($"{NavigationManager.Uri}").GetLeftPart(UriPartial.Authority);
        string file = Path.GetFileName(fileName);
        await JSRuntime.InvokeVoidAsync("DownloadFile", $"{uri}{fileName}", file);

    }
    private async Task ScrollToBottom()
    {
        await JSRuntime.InvokeVoidAsync("ScrollToBottom","none");
    }
    async Task Animation()
    {
        this.swap_value = "running...";
        string temp, statusFile, t;
        temp = "";
        t = "";
        statusFile = Path.Combine(YouwebStatic.GetRoot("download"), "status.text");
        while(!this.Command.IsCompleted)
        {
            await Task.Delay(200);
            this.RunBtnText = this.Swap();
            if (!Get.IsFileBusy(statusFile) && File.Exists(statusFile))
            {
                t =  File.ReadAllTextAsync(statusFile).Result;
            }
            if (temp != t)
            {
                //this.ReturnCommand += $"<p>{t}</p>";
                Returns.Add($"{t}");
                await ScrollToBottom();
                temp = t;
            }

            InvokeAsync(() =>
              {
                  StateHasChanged();
              });

        }
        // await Task.Run(async () => { this.ReturnCommand = CommandProcess.StandardOutput.ReadToEnd(); });
        this.RunBtnText = "run";
        InvokeAsync(() =>
            {
                StateHasChanged();
            });

    }
    private void RunInternalFunction()
    {
        if (this.Cmd == "clear")
        {
            this.Returns.Clear();
            this.Program = "";
            this.Cmd = "";
            //this.Arguments = "";
            return;
        }


    }

    private Task<bool> IsInternalCommand()
    {
        string cmd = this.Program;
        string args = null;//this.ParseCommands(GetArgsText);
        switch(cmd)
        {
            case "send":
               return Task<bool>.Run(async () =>
                {
                    string[] args = GetArgsArray();
                    UMessage message = new UMessage()
                    {
                        RName = this.SessionId,
                        Action = args[0],
                        Type = args[1],
                        Arguments = $""
                    };
                    UShare share = new UShare(this.SessionId);
                    await share.Send(message);
                    //await this.DownloadFile(args);
                    return true;
                });
            case "get":
                return Task<bool>.Run(async () =>
                {
                    await this.DownloadFile(args);
                    return true;
                });
            case "shell":
            case "qt":
            case "clownshell":
            case "clown":
                return Task<bool>.Run(async () =>
                {
                    await ClownShell.Init.Program.Main(args.Split(' '));
                    return true;
                });
            default:
                return Task<bool>.Run(async () =>
             {
                 return false;
             });

        }
    }
    bool IsActive { get; set; } = false;
    async Task RunCmd()
    {
        this.RunInternalFunction();

        if (IsActive == true) return;
        // Running an anonymous function asynchronously
        this.Command = Task.Run(async () =>
        {

            try
            {
                if (await this.IsInternalCommand()) return;
                /*
                if (File.Exists(Path.Combine(YouwebStatic.GetRoot("download"), "status.text")))
                {
                    await File.WriteAllTextAsync(Path.Combine(YouwebStatic.GetRoot("download"), "status.text"), "");
                }
                */
                if (string.IsNullOrEmpty(this.Cmd)) return;
                string path;
                path = YouwebStatic.GetRoot();

                CommandProcess = Process.Start(new ProcessStartInfo()
                {
                    FileName =  this.ParseCommands(this.Program),
                    Arguments = this.ParseCommands(this.GetArgsText()),
                    RedirectStandardOutput = true,
                    UseShellExecute = false, // Required for redirection
                    CreateNoWindow = true // Optional: do not create a window

                });
                string output = await CommandProcess.StandardOutput.ReadToEndAsync();

              //  string ujson = Path.Combine(YouwebStatic.GetRoot("in"), $"{this.SongRName}.json");

                string logs = Path.Combine(YouwebStatic.GetRoot("out"), $"{this.SessionId}.out");

                CommandProcess.WaitForExit();
                //if (!File.Exists(logs)) File.Create(logs);
                output += $"\nExit Code: {CommandProcess.ExitCode}\n";
                output += $"\nLog Time: {DateTime.Now.ToString("MM/dd/yyyy hh:mm:ss")}\n";
                await File.AppendAllTextAsync(logs, output);
                this.Returns.Add("**START**");
                this.Returns.Add(output);
                this.Returns.Add("**END**");

                this.IsActive = false;
                InvokeAsync(() =>
                {
                    StateHasChanged();
                });
            }
            catch(Exception ex)
            {
                this.Returns.Add($"{ex}");
                this.IsActive = false;

                InvokeAsync(() =>
               {
                   StateHasChanged();
               });
            }

        });

        this.PlayAnimation = Task.Run(async () => { Animation(); });
        // Optionally, wait for the task to complete
        await this.Command;
        await this.PlayAnimation;




    }


}
